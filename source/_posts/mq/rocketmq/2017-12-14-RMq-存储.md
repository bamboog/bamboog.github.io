---
layout: post
title: RMQ_存储
date: 2017-12-14
tags: MQ
---
## RMQ_存储

1. 调用：
```java
>>>> SendMessageProcessor.processRequest.sendMessage
>>>> MessageStore.putMessage
>>>> DefaultMessageStore.putMessage
>>>> commitLog.putMessage
>>>> mappedFile.appendMessage
```
2. 结构
3. 设计原理
    - ##### Page Cache
    在Linux系统中写入数据的时候并不会直接写到硬盘上，
    而是会先写到Page Cache中，并打上dirty标识，
    由内核线程flusher定期将被打上dirty的页发送给IO调度层，
    最后由IO调度决定何时落地到磁盘中，
    而Linux一般会把还没有使用的内存全拿来给Page Cache使用。
    而读的过程也是类似，会先到Page Cache中寻找是否有数据，有的话直接返回，
    如果没有才会到磁盘中去读取并写入Page Cache然后再次读取Page Cache并返回。
    而且读的这个过程中操作系统也会有一个预读

    - ##### mmap（0拷贝）
      - 文件映射到虚拟内存的技术,可以将文件在磁盘位置的地址和在虚拟内存中的虚拟地址通过映射对应起来,之后就可以在内存这块区域进行读写数据,而不必调用系统级别的read,write这些函数,从而提升IO操作性能;

    - #### 对比
      - read/write系统调用会有以下的操作：
        - 访问文件，这涉及到用户态到内核态的转换
        - 读取硬盘文件中的对应数据，内核会采用预读的方式，比如我们需要访问100字节，内核实际会将按照4KB(内存页的大小)存储在page cache中
        - 将read中需要的数据，从page cache中拷贝到用户缓冲区中

     - mmap系统调用与read/write调用的区别在于：
       - mmap只需要一次系统调用，后续操作不需要系统调用
       - 访问的数据不需要在page cache和用户缓冲区之间拷贝
    -

4.
