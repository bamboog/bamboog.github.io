#### CAP
- 因为
  ```
  上面这个系统怎么满足 CAP 呢？
  C：当节点A更新的时候，节点B也要更新，
  A：必须保证两个节点都是可用的，
  P：当节点 A,B 出现了网络分区，必须保证对外可用。
  可见，根本完成不了，只要出现了网络分区，A 就无法满足，因为节点 A 根本连接不上节点 B。
  如果强行满足 C 原子性，就必须停止服务运行，从而放弃可用性 C。
  ```

- 所以
  ```
  CA	满足原子和可用，放弃分区容错。说白了，就是一个整体的应用。  
  CP	满足原子和分区容错，也就是说，要放弃可用。当系统被分区，为了保证原子性，必须放弃可用性，让服务停用。
  AP	满足可用性和分区容错，当出现分区，同时为了保证可用性，必须让节点继续对外服务，这样必然导致失去原子性。
  ```

- 改变
```
仔细想想，分区是百分之百出现的吗？如果不出现分区，那么就能够同时满足 CAP。
如果出现了分区，可以根据策略进行调整。比如 C 不必使用那么强的一致性，可以先将数据存起来，稍后再更新，实现所谓的 “最终一致性”。
```
####  Base ----- BASE 协议是在可用性和一致性之间做的取舍和妥协。
- 理论
  ```
  BASE：全称：
  Basically Available(基本可用)----假设系统，出现了不可预知的故障，但还是能用
  Soft state（软状态）----多个不同节点的数据副本存在数据延时。,
  Eventually consistent（最终一致性) --- 上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性。从而达到数据的最终一致性
  ```

#### 2PC---Two-Phase Commit



#### 3PC



#### Paxos  --  少数服从多数,权利


#### Raft 是一种为了管理复制日志的一致性算法。
  -  领导人选举和日志复制
  -  领导选举基于一个随机的时间来保证不会冲突（如果冲突的话）。
  而日志复制则类似于 2PC。通常 5 个节点，只要不超过 2 个节点死亡都不会影响系统的运行。
  保证了系统的可用性，通过领导者的日志复制，实现了系统的一致性

  -

#### ZAB   Zookeeper Atomic Broadcast（Zookeeper 原子广播协议
- 原理
  ```  
  ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持 崩溃恢复 和 原子广播 协议;
  简而言之，当 Leader 服务可以正常使用，就进入消息广播模式，当 Leader 不可用时，则进入崩溃恢复模式。
  所有客户端写入数据都是写入到 主进程（称为 Leader）中，然后，由 Leader 复制到备份进程（称为 Follower）中。
  从而保证数据一致性。从设计上看，和 Raft 类似。
  ```
-  消息崩溃
  - 假设1：Leader 在复制数据给所有 Follwer 之后崩溃，怎么办？
  假设2：Leader 在收到 Ack 并提交了自己，同时发送了部分 commit 出去之后崩溃怎么办？
  -
  ```
  ZAB 协议确保那些已经在 Leader 提交的事务最终会被所有服务器提交。
  ZAB 协议确保丢弃那些只在 Leader 提出/复制，但没有提交的事务。
  针对这个要求，如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群总所有机器编号（即 ZXID 最大）的事务，
  那么就能够保证这个新选举出来的 Leader 一定具有所有已经提交的提案。
  而且这么做有一个好处是：可以省去 Leader 服务器检查事务的提交和丢弃工作的这一步操作。

  这样，我们刚刚假设的两个问题便能够解决。假设 1 最终会丢弃调用没有提交的数据，
  假设 2 最终会同步所有服务器的数据。这个时候，就引出了一个问题，如何同步？



  ZAB 协议和我们之前看的 Raft 协议实际上是有相似之处的，比如都有一个 Leader，用来保证一致性（Paxos 并没有使用 Leader 机制保证一致性）。再有采取过半即成功的机制保证服务可用（实际上 Paxos 和 Raft 都是这么做的）。

  ZAB 让整个 Zookeeper 集群在两个模式之间转换，消息广播和崩溃恢复，消息广播可以说是一个简化版本的 2PC，通过崩溃恢复解决了 2PC 的单点问题，通过队列解决了 2PC 的同步阻塞问题。

  而支持崩溃恢复后数据准确性的就是数据同步了，数据同步基于事务的 ZXID 的唯一性来保证。通过 + 1 操作可以辨别事务的先后顺序。


  ```


- 原子广播
  ```
  ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个 二阶段提交过程。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数成功响应，则执行 commit 操作（先提交自己，再发送 commit 给所有 Follwer）。
  ```
  - 将数据都复制到 Follwer 中
  - 等待 Follwer 回应 Ack，最低超过半数即成功
  - 当超过半数成功回应，则执行 commit ，同时提交自己
